## Toc

# Network
네트워크란 무엇일까요?
컴퓨터 A와 B가 있고 노트북과 데스크톱, 클라우드 VM이 있을때
시스템 A가 어떻게 B와 연결되죠?

## Switch and Routing
스위치는 두 시스템을 포함하는 네트워크를 만듭니다.
그걸 스위치에 연결하려면 각 호스트에 물리적 또는 가상 인터페이스(Network interface)가 필요합니다 
호스트 인터페이스를 보기 위해서는 IP 링크 명령을 사용하죠
```bash
ip link
# eth0
```

이 경우엔 A(`eth0`),B(`docker0`)의 이란 이름의 인터페이스(NIC)를 보죠, 스위치에 연결하는 데 사용할 겁니다.
각 인터페이스에 대해 IP 주소를 할당해야 합니다. 우리는 `ip addr` 명령을 사용합니다.
```bash
ip addr add 192.168.1.10/24 dev eth0
ip addr add 192.168.1.11/24 dev docker0
# in 192.168.1.0 host network
ping 192.168.1.11
ping 192.168.1.10
```
우리는 host s1(192.168.1.0)  내에서 A, B와 통신할 수 있습니다.

그렇다면 s2(192.168.2.0 host network) s2 내에 C(192.168.2.10),D(192.168.2.11)와 통신하기 위해서 어떻게 해야할까요?
이때 등장하는 것이 라우터입니다. 라우터는 두 네트워크를 연결하는 장치입니다.
라우터는 두 네트워크와 각각 연결된 인터페이스(라우터 인터페이스)를 가지고 있습니다. 
예시는 r1(192.168.1.1) interface 를 통해 s1과 연결하고, r2(192.168.2.1) interface 를 통해 s2와 연결하여 두 네트워크를 연결합니다.
좋습니다. 그러면 B에서 C로 패킷을 보내고 싶다면 어떻게 해야할까요?

먼저 라우터는 그저 네트워크의 경계에 있는 장치(네트워크 장비의 일종으로,패킷(packet, 네트워크 전송 데이터의 최소 단위)을 다른 네트워크 보내주는(forward) 역할을 한다.)일 뿐입니다.  
그래서 B는 패킷을 보내기 위해 라우터에게 패킷을 전달해야 합니다.
```bash
# to see routing table
route
```
> result
```
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         normal-router   0.0.0.0         UG    100    0        0 enp2s0f0
normal-router 0.0.0.0         255.255.255.255 UH    100    0        0 enp2s0f0
```

출발지 RNIC(라우터 인터페이스)룰 통해 라우터와 연결된 다른 subnet(switch)으로 경로를 등록할 수 있습니다.
```
<!-- use r1 to reach the s2 -->
ip route add 192.168.2.0/24 via 192.168.1.1
<!-- use r2 to reach the s1 --><!--  -->
ip route add 192.168.1.0/24 via 192.168.2.1

<!-- need access to Google at 172.217.194.0 network on the internet. -->
ip route add 172.217.194.0/24 via 192.168.2.1
```
우리는 여러 라우터를 구성할 수도 `ex) private network, public network` 있습니다.
늘 게이트웨이를 통해 인터넷과 연결될 필요는 없습니다.
지금 까지 구성한 라우터만으로도 로컬 네트워크에서 통신할 수 있습니다.

하지만 public network에 router는 게이트웨이가 필요합니다.
```
<!-- need access to Google at 172.217.194.0 network on the internet. -->
ip route add 172.217.194.0/24 via 192.168.2.1
```
목적지를 하나하나 설정해줘야 한다면 너무 귀찮겠죠? 그래서 우리는 default route를 설정합니다.
```bash
ip route add default via $AnyRouterIP
# or
ip route add 0.0.0.0 via $AnyRouterIP
```
> 참고로 ‘tracert(trace route)’ 명령은 목적지까지 거치는 라우터를 추적하는 역할이다.

한 호스트 네트워크에서 두 개의 NIC는 전달(forward) 되지 않습니다 (보안)
예로 r1(public network)과 r2(private network)가 있고, r1은 인터넷과 연결되어 있고, r2는 로컬 네트워크와 연결되어 있습니다.
이때 r1 으로 부터 들어오는 요청은 임의로 r2로 들어가서는 안됩니다.
명시적으로 허용을 위해서는 `/proc/sys/net/ipv4/ip_forward` 파일을 수정해야 합니다.
```
<!-- allow forwarding -->
1
<!-- disallow -->
0
```

### 도움이 될만한 명령어들
```bash
# list an modify interface on the host
ip link
# add bridge
ip link add br0 type bridge
# up bridge
ip link set br0 up
# ip addresses assigned to the interfaces
ip addr
```
이 명령어들은 오직 시스템이 restart 되어야 적용됩니다.
영구적 적용을 위해서는 `/etc/network/interfaces` 파일을 수정해야 합니다.


## Network Namespace
* 네트워크 스택을 격리하는 가상화 기술입니다.
* `ip netns list` 명령어를 통해 네임스페이스를 확인할 수 있습니다.
OCI 이미지를 빌드할 때 Command 키워드는 컨테이너내에서 첫 번째로 실행할 프로세스를 지정할 수 있습니다.
예로 `docker run -it ubuntu bash` 명령어를 실행하면 *bash* 프로세스가 실행됩니다.
즉 컨테이너 내에서 `ps aux` 명령어를 실행하면 PID=1 로서 *bash* 가 실행됩니다.
하지만 host 에서 `ps aux` 명령어를 실행하면 PID=1가 아닌 다른 프로세스 ID가 출력됩니다.
이는 컨테이너가 생성될 때 컨테이너의 네임스페이스를 생성하고, 네임스페이스 내에서 프로세스를 실행하기 때문입니다.

호스트 네트워크에서 컨테이너의 어떠한 네트워크도 보이지 않습니다.
왜냐하면 컨테이너는 네임스페이스는 별도의 이더넷 인터페이스(vth)를 생성하여
네트워크 인터페이스, 라우팅 테이블, ARP 테이블, IP 룰, IP 주소 공간 등을 격리하기 때문입니다.

### Veth(이더넷 인터페이스)
veth는 쌍으로 만들어지며 네트워크 네임스페이스들을 터널로서 연결하거나, 물리 디바이스와 다른 네트워크 네임스페이스의 장비를 연결하는 용도로 사용할 수 있습니다.


생성해 볼까요
```bash
# create veth pair
ip link add veth-red type veth peer name veth-blue
# set veth-red to red namespace
ip link set veth-red netns red
# set veth-blue to blue namespace
ip link set veth-blue netns blue
```
> 참고로 veth-red 와 veth-blue 는 같은 물리적 네트워크 인터페이스를 공유합니다.

 빨간색 네임스페이스에 ip 192.168.15.1을, 파란색 네임스페이스에 ip 192.168.15.2를 할당 하겠습니다.
```bash
ip -n red addr add 192.168.15.1 dev veth-red
ip -n blue addr add 192.168.15.2 dev veth-blue

# activate vth
ip -n red link set veth-red up
ip -n blue link set veth-blue up
```

두 네임스페이스가 서로 통신할 수 있습니다.
```bash
# ping from red to blue
ip netns exec red ping 192.168.15.2
# ping from blue to red
ip netns exec blue ping 192.168.15.1

# check arp table of red(blue address: 192.168.15.2)
ip netns exec red arp -n
# check arp table of blue(red address: 192.168.15.1)
ip netns exec blue arp -n
```

그리고 이 만들어진 vth들을 외부 네트워크와 연결하고 싶다면 어떻게 해야할까요?
물리적 네트워크와 같이 동작하게 하려면 스위치를 사용해야 합니다.
가상 스위치, 브릿지를 만들어 볼까요?
```bash
# create bridge
ip link add v-net-0 type bridge
# activate bridge
ip link set dev v-net-0 up
ip link
```
이제 호스트에 연결될 인터페이스가 보입니다.
이건 우리 호스트와 네임스페이스를 연결하는 인터페이스라고 생각하면 됩니다.

이전에 직접 링크한 veth-blue, veth-red 를 지우겠습니다.
```bash
ip -n red link del veth-red 
ip -n blue link del veth-blue
```

그리고 다시 브릿지에 연결하겠습니다.
```bash
ip link add veth-red type veth peer name veth-red-br
ip link add veth-blue type veth peer name veth-blue-br

ip link set veth-red netns red
ip link set veth-red-br master v-net-0

ip link set veth-blue netns blue
ip link set veth-blue-br master v-net-0
```
다시 각각 ip를 할당합니다.
```bash
ip -n red addr add 192.168.15.1 dev veth-red
ip -n blue addr add 912.168.15.2 dev veth-blue
# activate vth
ip -n red link set veth-red up
ip -n blue link set veth-blue up
```
이렇게 브릿지를 통해 네임스페이스간 네트워크가 생성되었습니다.

호스트와 네임스페이스가 통신이 가능할까요?
```bash
ping 192.168.15.1
```
정답은 No 입니다.

브릿지(네임스페이스)는 호스트 네트워크와 연결되지 않아있습니다. 
호스트와 연결하려면 어떻게 해야할까요? 
vth는 같은 물리적 네트워크 인터페이스를 공유합니다. 우리는 그저 IP 주소를 할당하면 됩니다.  
이를 통해 네임스페이스에 접근할 수 있습니다.
```bash
ip addr add 192.168.15.5/24 dev v-net-0
```
이제 핑이 잘될겁니다 큭큭
하지만 이 네트워크는 아직 private(*192.168.15.0*) 입니다. 어떠한 인터페이스도 외부 네트워크와 연결되어 있지 않습니다.
오직 eth0(ethernet, 192.168.1.2) 인터페이스만 외부 네트워크와 연결되어 있습니다.

만약 외부 네트워크(LAN)과 연결 하고 싶다면 어떻게 해야할까요?
우린 이전 네트워크 *192.168.15.0/24* 를 eth0(*192.168.1.2*) 를 통해 LAN(*192.168.1.0*) 네트워크 대역에서 
외부 네트워크 eth1(192.168.1.3) 대역 네트워크와 연결할 수 있습니다.
```bash
# 브릿지를 통해 LAN 네트워크와 연결
ip netns exec blue ip route add 192.168.1.0/24 via 192.168.15.5
```
이제 우리는 eth1(192.168.1.3) 와 통신이 가능할까요?
`ip netns exec blue ping 192.168.1.3` 명령어를 실행해보세요.
안됩니다. 우리 blue는 private network에 있기 때문입니다.
외부로 패킷은 내보낼 수 있지만, 외부에서 패킷을 받을 수 없습니다.
외부에서 패킷을 받기 위해서는 Gateway network 내에서 NAT(Network Address Translation)을 활성화 해야합니다.

```bash
# MASQUERADE: NAT
# 192.168.15.0/24: This specifies the source of the packets.
# MASQUERADE: source IP of the packets is not known until the packets are routed.
iptables -t nat -A POSTROUTING -s 192.168.15.0/24 -j MASQUERADE
``` 
LAN 네트워크 연결이 되었습니다.
마지막으로 우리는 네임스페이스 blue가 인터넷에 연결되기를 원합니다. 
> 가정1: LAN이 인터넷에 연결되어 있다
> 가정2: blue namespace 의 80 포트로 웹서버가 실행되고 있다.

물론 직접 연결로 가능하겠지만 우리는 iptables를 사용해 보겠습니다.

```bash
# This matches destination port 80, which is typically used for HTTP traffic.
# --to-destination 192.168.15.2:80: This is the new destination of the packet. In this case, it's IP address 192.168.15.2 on port 80.
# -j DNAT: This is the target of the rule. DNAT is a form of Destination NAT that alters the destination IP address of the packet to route it to a specified address.
#  DNAT는 패킷의 대상 IP 주소를 변경하여 지정된 주소로 라우팅하는 대상 NAT의 한 형태입니다.
iptables -t nat -A PREROUTING --dport 80 --to-destination 192.168.15.2:80 -j DNAT
```
결론: 그래도.. 한번에 양방향 통신이 가능한게 어디냐.. ㅠㅠ


### ARP(Address Resolution Protocol)
ARP는 IP 주소를 물리적 네트워크 주소(MAC)로 매핑하는 프로토콜입니다.

## Bridge
브리지는 두 개의 네트워크를 연결하는 장치입니다. 브리지는 두 개의 네트워크 인터페이스를 가지고 있습니다.



## Refer
* https://www.44bits.io/ko/post/container-network-2-ip-command-and-network-namespace
* 




