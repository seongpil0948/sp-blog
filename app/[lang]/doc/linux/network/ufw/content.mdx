## Toc

# Network
네트워크란 무엇일까요?
컴퓨터 A와 B가 있고 노트북과 데스크톱, 클라우드 VM이 있을때
시스템 A가 어떻게 B와 연결되죠?

## 도움이 될만한 명령어들

### ip link

```bash
# list an modify interface on the host
ip link
# add bridge
ip link add br0 type bridge
# up bridge
ip link set br0 up
# ip addresses assigned to the interfaces
ip -c add
# or 
ip addr # or ip a


```
이 명령어들 즉, ip 커맨드는 시스템이 restart 되면 리셋됩니다. 테스트 용도로 사용하기 좋습니다.
`netplan get` 명령어를 통해 현재 설정을 확인할 수 있습니다.
영구변경을 원한다면 아래 파일을 수정하고
```sh
cat /etc/netplan/00-installer-config.yaml
```
예시임, 네트워크 인터페이스, IP 주소, DNS 서버, 라우팅 정보 등을 구성합니다.
```yaml
network:
  ethernets:
    enp0s3:
      # DHCP를 통해 IPv4 주소를 자동으로 할당받도록 설정합니다.
      dhcp4: true
      # 이 인터페이스에 할당할 IP 주소를 지정합니다
      # addresses:
        # - 10.12.34.56/24
  version: 2
``` 
이후 아래 명령어를 통해 반영합니다.
```sh
# for dry run
sudo netplan try

# force apply
sudo netplan apply
```
> 참고로 `netplan` 은 `networkd` 를 위한 설정 도구입니다. `networkd` 는 `systemd` 의 일부입니다.

하지만 명령어를 통해 설정을 변경하는것은 잠재적 위험이 있습니다.
시스템 시작시 `/etc/netplan` 경로를 alphabetical order 로 읽기 때문에
`/etc/netplan/01-network-manager-all.yaml` 파일을 작성하면 덮어씌워집니다.

아래 파일을 수정하면 됩니다.

```yaml
# /etc/netplan/01-network-manager-all.yaml
network:
  ethernets:
    enp0s3:
      dhcp4: false
      addresses:
        - 10.12.34.56/24
        - 192.168.0.103/24
        - fe80::9640:c9ff:fe26:370c/64
      nameservers:
        # resolve ip address from domain name that is not in /etc/hosts
        # query to below dns servers 
        addresses:
          - 8.8.4.4
          - 8.8.8.8
      routes:
        # 192.168.0.0/24 네트워크로 향하는 트래픽을 10.0.0.100 게이트웨이를 통해 라우팅합니다.
        - to: 192.168.0.0/24
          via: 10.0.0.100
        # 다른 네트워크로 향하는 트래픽은 10.0.0.1 게이트웨이를 통해 라우팅됩니다.
        - to: default
          via: 10.0.0.1
  version: 2
``` 
반영 후 `ip route `의 `routes` 필드 반영 여부를 확인
` resolvectl status` 명령어를 통해 `nameservers` 필드 반영 여부를 확인
글로벌 적용은 `/etc/resolv.conf` 파일을 수정하면 됩니다.
```
# /etc/resolv.conf
[Resolve]
DNS=8.8.8.8 1.1.1.1
```
이후 `systemd-resolved` 서비스를 재시작합니다.
```sh 
sudo systemctl restart systemd-resolved
resolvectl dns
```
더 많은 예제는 `/usr/share/doc/netplan/examples` 에서 확인할 수 있습니다.






영구적 적용을 위해서는 `/etc/network/interfaces` 파일을 수정해야 합니다.  

#### 네트워크 디바이스 별 설명
- eht0: 물리적 네트워크 인터페이스: ethernet card
- enp0s3: 물리적 네트워크 인터페이스
  - /link/ether 일 경우 ethernet card
- docker0: 가상 네트워크 인터페이스: docker bridge
- br0: 가상 네트워크 인터페이스: bridge
- veth: 가상 네트워크 인터페이스: veth pair
- lo: 루프백 인터페이스: loopback interface
  - it's virtual interface
  - it's used for communication between processes on the same host(i.e server request itself)

## Switch and Routing
스위치는 두 시스템을 포함하는 네트워크를 만듭니다.
그걸 스위치에 연결하려면 각 호스트에 물리적 또는 가상 인터페이스(Network interface)가 필요합니다 
호스트 인터페이스를 보기 위해서는 IP 링크 명령을 사용하죠
```bash
ip link
```


이 경우엔 A(`eth0`),B(`docker0`)의 이란 이름의 인터페이스(NIC)를 보죠, 스위치에 연결하는 데 사용할 겁니다.
각 인터페이스에 대해 IP 주소를 할당해야 합니다. 우리는 `ip addr` 명령을 사용합니다.
```bash
ip addr add 192.168.1.10/24 dev eth0
ip addr add 192.168.1.11/24 dev docker0
# in 192.168.1.0 host network
ping 192.168.1.11
ping 192.168.1.10
```
우리는 host s1(192.168.1.0)  내에서 A, B와 통신할 수 있습니다.

그렇다면 s2(192.168.2.0 host network)  내에 C(192.168.2.10),D(192.168.2.11)와 통신하기 위해서 어떻게 해야할까요?  
이때 등장하는 것이 라우터입니다. 라우터는 두 네트워크를 연결하는 장치입니다.  
라우터는 두 네트워크와 각각 연결된 인터페이스(라우터 인터페이스)를 가지고 있습니다.   
예시는 r1(192.168.1.1) interface 를 통해 s1과 연결하고, r2(192.168.2.1) interface 를 통해 s2와 연결하여 두 네트워크를 연결합니다.  
좋습니다. 그러면 B에서 C로 패킷을 보내고 싶다면 어떻게 해야할까요?

먼저 라우터는 그저 네트워크의 경계에 있는 장치(네트워크 장비의 일종으로,패킷(packet, 네트워크 전송 데이터의 최소 단위)을 다른 네트워크 보내주는(forward) 역할을 한다.)일 뿐입니다.  
그래서 B는 패킷을 보내기 위해 라우터에게 패킷을 전달해야 합니다.
```bash
# to see routing table
route
```
> result
```
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         normal-router   0.0.0.0         UG    100    0        0 enp2s0f0
normal-router 0.0.0.0         255.255.255.255 UH    100    0        0 enp2s0f0
```

출발지 RNIC(라우터 인터페이스)룰 통해 라우터와 연결된 다른 subnet(switch)으로 경로를 등록할 수 있습니다.
```sh
# use r1 to reach the s2 
ip route add 192.168.2.0/24 via 192.168.1.1
# use r2 to reach the s1  
ip route add 192.168.1.0/24 via 192.168.2.1

# need access to Google at 172.217.194.0 network on the internet. 
ip route add 172.217.194.0/24 via 192.168.2.1
```
우리는 여러 라우터를 구성할 수도 `ex) private network, public network` 있습니다.
늘 게이트웨이를 통해 인터넷과 연결될 필요는 없습니다.
지금 까지 구성한 라우터만으로도 로컬 네트워크에서 통신할 수 있습니다.

하지만 public network에 router는 게이트웨이가 필요합니다.
```sh
# need access to Google at 172.217.194.0 network on the internet. 
ip route add 172.217.194.0/24 via 192.168.2.1
```
목적지를 하나하나 설정해줘야 한다면 너무 귀찮겠죠? 그래서 우리는 default route를 설정합니다.
```bash
ip route add default via $AnyRouterIP
# or
ip route add 0.0.0.0 via $AnyRouterIP
```
> 참고로 ‘tracert(trace route)’ 명령은 목적지까지 거치는 라우터를 추적하는 역할이다.

한 호스트 네트워크에서 두 개의 NIC는 전달(forward) 되지 않습니다 (보안)
예로 r1(public network)과 r2(private network)가 있고, r1은 인터넷과 연결되어 있고, r2는 로컬 네트워크와 연결되어 있습니다.
이때 r1 으로 부터 들어오는 요청은 임의로 r2로 들어가서는 안됩니다.
명시적으로 허용을 위해서는 `/proc/sys/net/ipv4/ip_forward` 파일을 수정해야 합니다.
```
allow forwarding 
1
disallow 
0
```

## Network Namespace
* 네트워크 스택을 격리하는 가상화 기술입니다.
* `ip netns list` 명령어를 통해 네임스페이스를 확인할 수 있습니다.
OCI 이미지를 빌드할 때 Command 키워드는 컨테이너내에서 첫 번째로 실행할 프로세스를 지정할 수 있습니다.
예로 `docker run -it ubuntu bash` 명령어를 실행하면 *bash* 프로세스가 실행됩니다.
즉 컨테이너 내에서 `ps aux` 명령어를 실행하면 PID=1 로서 *bash* 가 실행됩니다.
하지만 host 에서 `ps aux` 명령어를 실행하면 PID=1가 아닌 다른 프로세스 ID가 출력됩니다.
이는 컨테이너가 생성될 때 컨테이너의 네임스페이스를 생성하고, 네임스페이스 내에서 프로세스를 실행하기 때문입니다.

호스트 네트워크에서 컨테이너의 어떠한 네트워크도 보이지 않습니다.
왜냐하면 컨테이너는 네임스페이스는 별도의 이더넷 인터페이스(vth)를 생성하여
네트워크 인터페이스, 라우팅 테이블, ARP 테이블, IP 룰, IP 주소 공간 등을 격리하기 때문입니다.

### Veth(이더넷 인터페이스)
veth는 쌍으로 만들어지며 네트워크 네임스페이스들을 터널로서 연결하거나, 물리 디바이스와 다른 네트워크 네임스페이스의 장비를 연결하는 용도로 사용할 수 있습니다.


생성해 볼까요
```bash
# create veth pair
ip link add veth-red type veth peer name veth-blue
# set veth-red to red namespace
ip link set veth-red netns red
# set veth-blue to blue namespace
ip link set veth-blue netns blue
```
> 참고로 veth-red 와 veth-blue 는 같은 물리적 네트워크 인터페이스를 공유합니다.

 빨간색 네임스페이스에 ip 192.168.15.1을, 파란색 네임스페이스에 ip 192.168.15.2를 할당 하겠습니다.
```bash
ip -n red addr add 192.168.15.1 dev veth-red
ip -n blue addr add 192.168.15.2 dev veth-blue

# activate vth
ip -n red link set veth-red up
ip -n blue link set veth-blue up
```

두 네임스페이스가 서로 통신할 수 있습니다.
```bash
# ping from red to blue
ip netns exec red ping 192.168.15.2
# ping from blue to red
ip netns exec blue ping 192.168.15.1

# check arp table of red(blue address: 192.168.15.2)
ip netns exec red arp -n
# check arp table of blue(red address: 192.168.15.1)
ip netns exec blue arp -n
```

그리고 이 만들어진 vth들을 외부 네트워크와 연결하고 싶다면 어떻게 해야할까요?
물리적 네트워크와 같이 동작하게 하려면 스위치를 사용해야 합니다.
가상 스위치, 브릿지를 만들어 볼까요?
```bash
# create bridge
ip link add v-net-0 type bridge
# activate bridge
ip link set dev v-net-0 up
ip link
```
이제 호스트에 연결될 인터페이스가 보입니다.
이건 우리 호스트와 네임스페이스를 연결하는 인터페이스라고 생각하면 됩니다.

이전에 직접 링크한 veth-blue, veth-red 를 지우겠습니다.
```bash
ip -n red link del veth-red 
ip -n blue link del veth-blue
```

그리고 다시 브릿지에 연결하겠습니다.
```bash
ip link add veth-red type veth peer name veth-red-br
ip link add veth-blue type veth peer name veth-blue-br

ip link set veth-red netns red
ip link set veth-red-br master v-net-0

ip link set veth-blue netns blue
ip link set veth-blue-br master v-net-0
```
다시 각각 ip를 할당합니다.
```bash
ip -n red addr add 192.168.15.1 dev veth-red
ip -n blue addr add 912.168.15.2 dev veth-blue
# activate vth
ip -n red link set veth-red up
ip -n blue link set veth-blue up
```
이렇게 브릿지를 통해 네임스페이스간 네트워크가 생성되었습니다.

호스트와 네임스페이스가 통신이 가능할까요?
```bash
ping 192.168.15.1
```
정답은 No 입니다.

브릿지(네임스페이스)는 호스트 네트워크와 연결되지 않아있습니다. 
호스트와 연결하려면 어떻게 해야할까요? 
vth는 같은 물리적 네트워크 인터페이스를 공유합니다. 우리는 그저 IP 주소를 할당하면 됩니다.  
이를 통해 네임스페이스에 접근할 수 있습니다.
```bash
ip addr add 192.168.15.5/24 dev v-net-0
```
이제 핑이 잘될겁니다 큭큭
하지만 이 네트워크는 아직 private(*192.168.15.0*) 입니다. 어떠한 인터페이스도 외부 네트워크와 연결되어 있지 않습니다.
오직 eth0(ethernet, 192.168.1.2) 인터페이스만 외부 네트워크와 연결되어 있습니다.

만약 외부 네트워크(LAN)과 연결 하고 싶다면 어떻게 해야할까요?
우린 이전 네트워크 *192.168.15.0/24* 를 eth0(*192.168.1.2*) 를 통해 LAN(*192.168.1.0*) 네트워크 대역에서 
외부 네트워크 eth1(192.168.1.3) 대역 네트워크와 연결할 수 있습니다.
```bash
# 브릿지를 통해 LAN 네트워크와 연결
ip netns exec blue ip route add 192.168.1.0/24 via 192.168.15.5
```
이제 우리는 eth1(192.168.1.3) 와 통신이 가능할까요?
`ip netns exec blue ping 192.168.1.3` 명령어를 실행해보세요.
안됩니다. 우리 blue는 private network에 있기 때문입니다.
외부로 패킷은 내보낼 수 있지만, 외부에서 패킷을 받을 수 없습니다.
외부에서 패킷을 받기 위해서는 Gateway network 내에서 NAT(Network Address Translation)을 활성화 해야합니다.

```bash
# MASQUERADE: NAT
# 192.168.15.0/24: This specifies the source of the packets.
# MASQUERADE: source IP of the packets is not known until the packets are routed.
iptables -t nat -A POSTROUTING -s 192.168.15.0/24 -j MASQUERADE
``` 
LAN 네트워크 연결이 되었습니다.
마지막으로 우리는 네임스페이스 blue가 인터넷에 연결되기를 원합니다. 
> 가정1: LAN이 인터넷에 연결되어 있다
> 가정2: blue namespace 의 80 포트로 웹서버가 실행되고 있다.

물론 직접 연결로 가능하겠지만 우리는 iptables를 사용해 보겠습니다.

```bash
# This matches destination port 80, which is typically used for HTTP traffic.
# --to-destination 192.168.15.2:80: This is the new destination of the packet. In this case, it's IP address 192.168.15.2 on port 80.
# -j DNAT: This is the target of the rule. DNAT is a form of Destination NAT that alters the destination IP address of the packet to route it to a specified address.
#  DNAT는 패킷의 대상 IP 주소를 변경하여 지정된 주소로 라우팅하는 대상 NAT의 한 형태입니다.
iptables -t nat -A PREROUTING --dport 80 --to-destination 192.168.15.2:80 -j DNAT
```
결론: 그래도.. 한번에 양방향 통신이 가능한게 어디냐.. ㅠㅠ


### ARP(Address Resolution Protocol)
ARP는 IP 주소를 물리적 네트워크 주소(MAC)로 매핑하는 프로토콜입니다.

## Bridge
브리지는 두 개의 네트워크를 연결하는 장치입니다. 브리지는 두 개의 네트워크 인터페이스를 가지고 있습니다.

### Gateway
집에서 인터넷을 사용할 때 라우터는 홈 네트워크에서 세계의 다른 네트워크로 데이터를 전송하는 데 도움이 되기 때문에 게이트웨이입니다.


## Refer
* https://www.44bits.io/ko/post/container-network-2-ip-command-and-network-namespace
* 



# Tasks

## 192.168.0.100:8083 에대한 경로를 분석해라

먼저 방화벽 규칙중 tcp, udp 프로토콜에 대한 규칙을 보자
```sh
# sudo iptables -L"


Chain DOCKER (1 references)
target     prot opt source               destination
ACCEPT     tcp  --  anywhere             172.17.0.2           tcp dpt:http


# 172.17.0.2 ip 를 가진 NIC이 들어오는 tcp 패킷을 허용한다.
```
이외에 딱히 DROP, QUEUE, SNAT -> DNAT 되는 규칙은 없다.
172.17.0.2 에 해당하는 주요 라우팅 테이블, NIC 주소를 살펴보자

```sh
# ip route 

# 다른 규칙과 일치하지 않는 모든 트래픽에 대한 기본 경로를 지정합니다.
# 패킷은 게이트웨이 192.168.0.1을 통해 인터페이스 enp2s0f0로 전송됩니다.
# 이 경로는 DHCP(동적 호스트 구성 프로토콜)를 통해 학습되었습니다.
# 나가는 트래픽의 소스 IP 주소는 192.168.0.100입니다.
# 경로의 메트릭(우선 순위)은 100입니다.
default via 192.168.0.1 dev enp2s0f0 proto dhcp src 192.168.0.100 metric 100
# 로컬 네트워크(192.168.0.0/24)에 직접 enp2s0f0를 통해 액세스합니다.
192.168.0.0/24 dev enp2s0f0 proto kernel scope link src 192.168.0.100

# Docker 네트워크(172.17.0.0/16)에 직접 docker0 인터페이스를 통해 액세스합니다.
# 이 경로는 커널(수동으로 추가되지 않음)에 의해 관리됩니다.
# 링크 로컬 경로이며, 즉 대상이 동일한 네트워크에 직접 연결되어 있음을 의미합니다.
# 이 네트워크로의 트래픽의 소스 IP 주소는 172.17.0.1입니다.
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1

# ip addr
2: enp2s0f0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 94:40:c9:26:3a:2c brd ff:ff:ff:ff:ff:ff
    inet 192.168.0.100/24 brd 192.168.0.255 scope global dynamic enp2s0f0
       valid_lft 83615sec preferred_lft 83615sec
    inet6 fe80::9640:c9ff:fe26:3a2c/64 scope link
       valid_lft forever preferred_lft forever
```
default 가 이더넷 인터페이스(enp2s0f0)로 설정되어 있지만 방화벽 필터에 따라 
192.168.0.0/24 요청이 올경우 docker0 인터페이스로 이동하는 것을 확인했습니다.


