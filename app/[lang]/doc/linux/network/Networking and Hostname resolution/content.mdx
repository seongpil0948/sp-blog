# Toc

## What is Networking and Hostname resolution?
hostname resolution 은 IP 주소를 호스트 이름으로 변환하거나 호스트 이름을 IP 주소로 변환하는 것을 의미합니다.  

### Configure static resolution so that naver.com  hostname resolves to IP address 8.8.8.8

```bash
$ echo "8.8.8.8         naver.com " | sudo tee -a  /etc/hosts
``` 
위 코드는 `naver.com ` 을 resolve 하기 위해서 `8.8.8.8` 의 nameserver 를 사용하도록 설정한다.  
- DNS 서버를 우회하여 IP 주소를 찾을 수 있게 해준다.
- /etc/hosts 에 위치한다.
- 우선순위가 가장 높다. 즉, hosts 파일에 등록된 내용이 DNS 서버에 등록된 내용보다 먼저 참조된다.
- 특정 도메인을 특정 IP 주소로 연결할 수 있다. 

이후 dig 명령어를 사용하여 확인한다.
```bash
$ nslookup naver.com                       
Server:         168.126.63.1
Address:        168.126.63.1#53

Non-authoritative answer:
Name:   naver.com
Address: 223.130.195.95
Name:   naver.com
Address: 223.130.200.104
Name:   naver.com
Address: 223.130.195.200
Name:   naver.com
Address: 223.130.200.107

```
위 명령어를 통해 naver.com 의 ip 주소를 확인할 수 있다 하지만 뭔가 이상하다   
`nameserver` 를 `168.126.63.1` 로 `8.8.8.8` 과 다른주소로 설정되어 있다.

`resolv.conf` 파일을 확인해보자
```bash
$ cat /etc/resolv.conf 

nameserver 168.126.63.1
nameserver 168.126.63.2
```
`resolv.conf` 파일은 도메인쿼리에 사용될 `nameserver` 정보를 가지고 있다.  
그외 각 OS 별 도메인 쿼리에 사용되는 파일은 여러가지가 있으니 참고하자.
> Mac OS : dns-sd(1), scutil(8)
만약 `8.8.8.8` nameserver 를 사용하고 싶다면 아래와 같이 설정한다.
```bash
$ nslookup naver.com 8.8.8.8
```

#TODO: dig, nslookup 명령어에 대한 설명 추가



---  

### Our system uses dynamic network configuration. Leave it as it is, dynamically configured, but add an extra IP to eth1 interface on this system

```bash
sudo ip a add 10.0.0.50/24 dev eth1
#  if you needed
sudo nmcli device reapply eth1
```
-  ip 명령어를 사용하여 eth1 인터페이스(device)에 ip 주소를 추가한다.

#### 깨알 상식: ip address add - add new protocol address.
자주 사용되는 옵션은 다음과 같다.
- `dev`: 해당 인터페이스에 주소를 추가한다.
- `broadcast` : 브로드캐스트 주소를 설정한다.
  - 예를 들어, 서버가 모든 클라이언트에게 업데이트 알림을 전송하거나, 프린터가 인쇄 작업을 위한 사용 가능한 프린터를 알릴 때 사용할 수 있습니다.
  - DHCP 서버는 브로드캐스트 메시지를 사용하여 클라이언트에게 IP 주소를 할당합니다.
  - 네트워크 관리자가 네트워크 설정 변경을 모든 장치에 적용해야 하는 경우 브로드캐스트 메시지를 사용하여 변경 사항을 알릴 수 있습니다.
example
```bash
$ ip address add broadcast 192.168.1.255 dev eth0
# check address of dev
$ ip address show dev eth0
2: eth0: <BROADCAST,MULTICAST> mtu 1500 qdisc pfifo_fast state UP group default
    link/ether 00:50:56:c0:00:08 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.10/24 brd 192.168.1.255 scope global eth0
       valid_lft forever preferred_lft forever
```
`192.168.1.255` 주소로  `192.168.1.10/24` 의 모든 패킷을 브로드캐스트 할 수 있다.
  - 네트워크 전체에 메시지를 전송:
    - `echo "안녕하세요, 모든 사용자 여러분!" | netcat -b 192.168.1.255 9`
  - 네트워크 스캐너 사용:
    - `nmap -sn 192.168.1.10/24`
- `label` : 인터페이스에 레이블을 추가합니다.
- 


### Get the list of all incoming open ports on this system and store the output in /home/bob/incoming.txt file.
```bash
sudo netstat -tulpn | grep LISTEN > /home/bob/incoming.txt
```

### Add a new DNS resolver 8.8.8.8 on this system.
```bash
sudo echo "nameserver 8.8.8.8" | sudo tee -a /etc/resolv.conf
```

### Identify the transient hostname of this system and save the value in /home/bob/t-hostname file.

`hostnamectl` 을 실행시키면 `hostname` 과 `static hostname` 을 확인할 수 있다.
- `hostname` : 현재 시스템의 호스트 이름
- `static hostname` : 시스템이 부팅될 때 사용되는 호스트 이름
  - same as `hostname` if not set
  - `transient hostname`라고도 불린다.
```bash
hostnamectl | grep "Transient" | awk '{print $3}' > /home/bob/t-hostname
```

### Now, update the static hostname to match the transient hostname on this system.
```bash
sudo hostnamectl set-hostname dev-host01
```

## Reference
- [naver blog 1](https://www.google.com/search?q=Networking+and+Hostname+resolution&oq=Networking+and+Hostname+resolution&gs_lcrp=EgZjaHJvbWUyBggAEEUYOdIBBzE5N2owajeoAgCwAgA&sourceid=chrome&ie=UTF-8)



### routing table example
> ip-route - routing table management  
[man page](https://man7.org/linux/man-pages/man8/ip-route.8.html)를 보는데에 도움이 될만한 내용을 알아보자

### ip route
먼저 `ip route` 명령어를 사용하여 현재 시스템의 라우팅 테이블을 확인한다.
조금 특이하게도 `via, dev, proto` 는 값이 아니라 라벨 혹은 필드명이다.
- `via` : 목적지까지 가는 경로를 찾기 위해 사용되는 게이트웨이 주소
- `dev` : 목적지까지 가는 경로를 찾기 위해 사용되는 네트워크 장치
- `proto` : 라우팅 테이블에 추가된 경로의 프로토콜
- `scope` : 경로의 범위
- `src` : 패킷이 나가는 인터페이스의 소스 주소
- `linkdown` : 링크가 다운되었음을 나타냅니다.
- `onlink` : 목적지가 직접 연결되어 있음을 나타냅니다.
- `blackhole` : 패킷이 버려지도록 지시합니다.

```bash
$ ip route
# 매칭이 안될경우 default route 를 사용한다.
# 어디든 가려면 eth1를사용해 192.168.0.1 을 통해 가라
default via 192.168.0.1 dev enp2s0f0 proto static
# 이 줄은 enp2s0f0 인터페이스에 직접 연결된 네트워크 172.25.0.0/24에 대한 경로를 지정합니다. 
# proto 커널 범위 링크는 이 경로가 커널에 의해 자동으로 생성되었음을 나타냅니다.
# src 172.25.0.47 부분은 이 네트워크의 Gateway ip 가 172.25.0.47임을 나타냅니다.
# 192.168.0.1 로 가는 모든 패킷은 enp2s0f0 인터페이스를 통해 172.25.0.0/24 로 가라
172.25.0.0/24 dev enp2s0f0 proto kernel scope link src 192.168.0.1

10.4.0.0/24 dev nerdctl0 proto kernel scope link src 10.4.0.1 linkdown
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown
172.28.0.0/16 dev br-dff5b71ada96 proto kernel scope link src 172.28.0.1
172.30.0.0/16 dev br-a48ffc8d8f56 proto kernel scope link src 172.30.0.1
172.31.0.0/16 dev br-4f950b7f01d8 proto kernel scope link src 172.31.0.1
# 192.168.0.1 로 가는 모든 패킷은 enp2s0f0 인터페이스를 통해 192.168.0.0/24 로 가라
192.168.0.0/24 dev enp2s0f0 proto kernel scope link src 192.168.0.101
192.168.49.0/26 via 192.168.0.102 dev enp2s0f0 proto 80 onlink
192.168.80.128/26 via 192.168.0.100 dev enp2s0f0 proto 80 onlink
192.168.133.64 dev cali8a6b142ea4e scope link
blackhole 192.168.133.64/26 proto 80
192.168.190.0/26 via 192.168.190.0 dev vxlan.calico onlink
``` 

### Temporarily route all traffic that must reach the 192.168.0.* network through the device that has the IP 172.28.128.100(RNIC)
그럼 위 내용에 기반하여, `192.168.0.0/24` 에 가는 모든 패킷을 `172.28.128.100` 을 통해 가도록 설정한다. 
```bash
# via: 을 통해~
sudo ip route add 192.168.0.0/24 via 172.28.128.100
```


### route 
```bash
# 목적지, 게이트웨이, 서브넷마스크
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         _gateway        0.0.0.0         UG    0      0        0 enp2s0f0
10.4.0.0        0.0.0.0         255.255.255.0   U     0      0        0 nerdctl0
172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0
172.28.0.0      0.0.0.0         255.255.0.0     U     0      0        0 br-dff5b71ada96
172.30.0.0      0.0.0.0         255.255.0.0     U     0      0        0 br-a48ffc8d8f56
172.31.0.0      0.0.0.0         255.255.0.0     U     0      0        0 br-4f950b7f01d8
192.168.0.0     0.0.0.0         255.255.255.0   U     0      0        0 enp2s0f0
192.168.49.0    192.168.0.102   255.255.255.192 UG    0      0        0 enp2s0f0
192.168.80.128  192.168.0.100   255.255.255.192 UG    0      0        0 enp2s0f0
192.168.133.64  0.0.0.0         255.255.255.255 UH    0      0        0 cali8a6b142ea4e
192.168.133.64  0.0.0.0         255.255.255.192 U     0      0        0 *
192.168.190.0   192.168.190.0   255.255.255.192 UG    0      0        0 vxlan.calico
```
아래는 `ip addr` 의 결과이다.
```text
2: enp2s0f0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 94:40:c9:26:39:7c brd ff:ff:ff:ff:ff:ff
    inet 192.168.0.101/24 brd 192.168.0.255 scope global enp2s0f0
       valid_lft forever preferred_lft forever
    inet6 fe80::9640:c9ff:fe26:397c/64 scope link
       valid_lft forever preferred_lft forever
4: br-a48ffc8d8f56: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default
    link/ether 02:42:65:f0:8b:2d brd ff:ff:ff:ff:ff:ff
    inet 172.30.0.1/16 brd 172.30.255.255 scope global br-a48ffc8d8f56
       valid_lft forever preferred_lft forever
    inet6 fe80::42:65ff:fef0:8b2d/64 scope link
       valid_lft forever preferred_lft forever
5: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default
    link/ether 02:42:bf:1c:27:5d brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:bfff:fe1c:275d/64 scope link
       valid_lft forever preferred_lft forever
```
만약  1.2.3.4 주소로 리디렉션한다고 상상해 보세요. 이는 위의 네트워크 범위에 맞지 않습니다.  
이경우 패킷은 `route` 테이블의 Gateway(router)를 확인하여(없을경우 default) destination 찾습니다.
그래서 커널은 패킷을 1.2.3.4로 

## Packet Filter
항상 방화벽 설정 전에는 ssh 연결조차 끊길 수 있다.
대비를 마련하자.

ufw의 한계를 극복하기 위해 iptables를 사용한다.
하지만 확장된 기능을 제공하는 ufw-framework 를 통해 사용성을 최대화 시킬 수 있다.
```sh
man ufw-framework
```

```bash
sudo ufw status
# Status: inactive
```
inactive 상태이면 아래 명령어로 활성화 시킨다.
```bash
sudo ufw enable
# Firewall is active and enabled on system startup
```
### Allow Permanent TCP incoming connections to port 7869
```bash
sudo ufw deny 7869/tcp
sudo ufw status
```
or for centos
```bash
sudo firewall-cmd --add-port=7869/tcp --permanent
sudo firewall-cmd --reload
```

### Add a permanent firewall rule to allow the https service.
```bash
sudo ufw allow https
```
or for centos
```bash
sudo firewall-cmd --add-service=https --permanent
```

### You will see that there is only one port allowing UDP traffic, remove it using below given command:
```bash
sudo ufw delete allow 53/udp
```
or for centos
```bash
# not permanent
sudo firewall-cmd --remove-port=53/udp
# to make all permanent
sudo firewall-cmd --runtime-to-permanent
```

### (10.11.12.0 ~ 10.11.12.255(예: 10.11.12.0/24))의 모든 IP에서 들어오는 모든 트래픽을 허용하고 신뢰할 수 있는 영역에 필요한 규칙을 추가하며 규칙은 영구적이어야 합니다.
```bash
# sudo ufw allow from 
```
or for centos
```bash
sudo firewall-cmd --add-source=10.11.12.0/24 --zone=trusted --permanent
```

## Port Redirection & NAT

### Setup
### check port forwarding
```bash
sudo sysctl net.ipv4.ip_forward
sudo sysctl -a | grep forward
```

# References
- [linux-ip-route](https://man7.org/linux/man-pages/man8/ip-route.8.html)