# Intro
2TB Solid State Drive(SSD)가 있다고 상상해 보세요. 그리고 그 위에 윈도우를 설치하고 싶지만 또한 리눅스 배포판도 설치하고 싶습니다.  
그리고 Windows는 NTFS 파일 시스템을 사용하고, Linux는 다른 ext4(extended file system 4) 시스템을 사용하기 때문에 문제가 있습니다.
우리는 SSD의 저장 공간을 간단히 나눌 수 있습니다.
윈도우용으로 1TB, 리눅스용으로 1TB를 예약합니다.
이러한 방식으로 스토리지 장치를 분할하는 것을 파티션이라고 합니다. 따라서 시나리오에서는 두 개의 파티션이 있습니다
각각 1TB의 크기입니다. 이제는 파티션과 사물이 논리적으로 분리되어 각 운영 체제가 자유롭게 자신의 일을 할 수 있습니다.  


## Partition

Linux 시스템에 어떤 파티션이 있는지 확인하려면 LHS VLC List BLOCK Devices 명령을 사용하면 됩니다.  
```bash
$ lsblk
# show example
NAME                      MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
# example 1
loop0                       7:0    0  63.3M  1 loop 
loop1                       7:1    0  91.9M  1 loop /snap/lxd/24061
loop2                       7:2    0  49.9M  1 loop 
loop3                       7:3    0  40.9M  1 loop /snap/snapd/20290
loop4                       7:4    0  63.5M  1 loop /snap/core20/2015
loop5                       7:5    0   368K  1 loop /snap/bpytop/261
loop6                       7:6    0  63.9M  1 loop /snap/core20/2105
loop7                       7:7    0  40.4M  1 loop /snap/snapd/20671
loop8                       7:8    0     2M  1 loop /snap/btop/655
nvme0n1                   259:0    0 238.5G  0 disk
├─nvme0n1p1               259:1    0   1.1G  0 part /boot/efi
├─nvme0n1p2               259:2    0     2G  0 part /boot
└─nvme0n1p3               259:3    0 235.4G  0 part
  └─ubuntu--vg-ubuntu--lv 253:0    0   100G  0 lvm  /
# example 2
sda                       8:0      0    20G  0 disk
├─sda1                    8:1      0     1G  0 part /boot
├─sda2                    8:2      0    19G  0 part
  ├─cs-root               253:1    0    10G  0 lvm  /
  ├─cs-swap               253:2    0     2G  0 lvm  [SWAP]
sdb                       8:16     0    10G  0 disk
sr0                       11:0     1  1024M  0 rom
```
우리는 이것을 Linux가 데이터를 저장하거나, 검색할 수 있는 저장 공간 블록으로 생각할 수 있습니다.
하지만 전부 partition은 아니고, `part`가 들어간 것만 partition입니다.
* SDA는 물리 디스크이며 여기에는 SDA 1과 SDA 2라는 두 개의 파티션이 포함되어 있습니다.
  * SATA 포트 직렬 ATA에 연결될 수 있는 모든 장치가 여기에 있습니다.
* 가상 머신 스토리지 장치는 일반적으로 구성 방식에 따라 문자 V로 시작합니다.
* nvme 저장 장치를 사용하는 경우 nvme로 시작하는 이름이 표시됩니다.
첫 글자와 블록 장치 이름은 덜 중요합니다. 도움이 되는건 마지막 글자입니다.  
예를 들어, 이 머신에 3개의 디스크가 있다면 SDA, SDB, SDC와 같은 이름을 갖게 됩니다.
그리고 sda1, sda2, sdb1, sdb2와 3, sdc1과 같은 파티션이 있을 수 있습니다.  
마지막 문자와 숫자를 사용하면 이 디스크가 어느 디스크인지, 어느 파티션인지 쉽게 알 수 있습니다.    

위의 예에서 우리는 3개의 디스크를 볼 수 있습니다.
* 첫 번째 디스크는 nvme0n1이라는 이름을 가지고 있습니다.
  * 이 디스크에는 3개의 파티션이 있습니다. (nvme0n1p1, nvme0n1p2, nvme0n1p3)
    * `nvme0n1p3`은 전체 디스크를 사용하는 LVM(Logical Volume Manager) 파티션입니다.
* 두 번째 디스크는 sda라는 이름을 가지고 있습니다.
  * 이 디스크에는 2개의 파티션이 있습니다. (sda1, sda2)
    * `sda2`는 전체 디스크를 사용하는 LVM 파티션입니다.
* 세 번째 디스크는 sdb라는 이름을 가지고 있습니다.
  * 이 디스크에는 0개의 파티션이 있습니다.

` sudo fdisk --list` 명령은 더 자세한 정보를 제공합니다.  
```bash
$ sudo fdisk --list
# example1
Disk /dev/sda: 20 GiB, 21474836480 bytes, 41943040 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
# Partition Table
Device     Boot   Start      End  Sectors  Size Id Type
/dev/sda1  *       2048  2099199  2097152    1G 83 Linux
/dev/sda2       2099200 41943039 39843840   19G 8e Linux LVM

# example2
Disk /dev/loop7: 40.44 MiB, 42393600 bytes, 82800 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes


Disk /dev/nvme0n1: 238.49 GiB, 256060514304 bytes, 500118192 sectors
Disk model: TS256GMTE110S
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: gpt
Disk identifier: 16C5F11C-CF26-48B4-A8B5-3D7F4F0E8BE2
# Partition Table
Device           Start       End   Sectors   Size Type
/dev/nvme0n1p1    2048   2203647   2201600   1.1G EFI System
/dev/nvme0n1p2 2203648   6397951   4194304     2G Linux filesystem
/dev/nvme0n1p3 6397952 500115455 493717504 235.4G Linux filesystem
```
우리는 Partition Table 의 end 컬럼이 다음 파티션의 start 컬럼과 이어지는 것을 볼 수 있습니다.
이것은 파티션이 다른 파티션을 덮지 않는다는 것을 의미합니다.  

위 `Section size` 는 512바이트입니다. 이것은 파티션의 최소 크기입니다.  
그리고 `/dev/nvme0n1p1` 의 시작은 2048이고, 그 둘을 곱하면 1048576 byte가 됩니다.  
이것은 1MB입니다. 이것은 파티션의 최소 크기입니다. 그리고 `nvme0n1p1` 이전 1MB는 여유공간이 있음을 알 수 있습니다.   
이 공간은 파티션 테이블을 위해 예약되어 있습니다.

때때로, 섹터 사이즈가 4096바이트인 경우도 있습니다. 이 경우에는 파티션의 최소 크기가 4096 * 2048 = 8388608바이트 즉, 8MB가 됩니다.  
### cfdisk
`cfdisk` 명령은 파티션을 만들고 삭제하는 데 사용할 수 있는 텍스트 기반 도구입니다.  
nvme0n1p4 파티션을 만들어 보겠습니다.  
```bash
$ sudo cfdisk /dev/nvme0n1
```

디스크의 데이터는 연속된 0과 1의 묶음일 뿐입니다. 따라서 운영 체제가 파티션이 시작되는 위치와 끝나는 위치를 알 수 있는 방법이 필요합니다.  
이것을 위해 파티션 테이블이 있습니다. 파티션 테이블은 디스크의 첫 번째 섹터에 저장됩니다.  
파티션 테이블은 파티션의 시작과 끝을 나타내는 데 사용되는 16바이트의 레코드를 포함합니다.

이 테이블은 MBR(dos) 또는 마스터 부트 레코드라고 불리는 디스크의 시작 부분에 저장되었습니다. 
MBR은 10년 전에는 표준이었지만 요즘은 GUID 파티션 테이블인 GPT로 마이그레이션되는 추세입니다.
MBR은 2TB보다 큰 디스크를 지원하지 않습니다.
MBR은 4개의 기본 파티션만 지원합니다. GPT는 128개의 기본 파티션을 지원합니다.
하지만 오래된 하드웨어에서는 MBR이 더 잘 작동할 수 있습니다.

GPT의 파티션 테이블은 손상될 가능성이 적고 더 많은 기본 파티션이 있고 훨씬 더 큰 파티션 크기를 사용하며 이에 대한 몇 가지 더 많은 이점을 제공합니다. 따라서 파티션을 만들기 전에 MBR을 사용할지 GPT를 사용할지 결정해야 합니다.

디스크에 Free space가 10G가 표시됩니다. 이것은 파티션을 만들 수 있는 공간입니다.
8GB를 새로운 OS에 할당하고 2GB를 스왑 파티션으로 할당하려고 합니다.    
이 GUI는 방향키와 엔터키를 사용하여 작동합니다.    
1. Free Space를 선택하고 New를 선택합니다. 이후 파티션의 크기를 입력할 수 있는 입력 prompt가 표시됩니다.  
2. 8G를 입력하고 엔터를 누릅니다, 생성되었습니다.
3. 다시 Free Space를 선택하고 New를 선택합니다. 2G를 입력하고 엔터를 누릅니다.   
4. 만약 더 추가하고싶다면 메인 파티션을 선택하고 Resize를 선택하고 4GB 입력하고 엔터를 누릅니다.
5. 남은 4GB가 다시 Free Space로 표시됩니다. 다시 New를 선택하고 4GB를 입력하고 엔터를 누릅니다.
6. Sort를 선택하고 파티션을 정렬합니다.
7. 2GB 파티션을 선택하고 Type을 선택합니다. 이것은 파티션의 유형을 변경합니다. Linux swap 선택 혹은, 82를 입력하고 엔터를 누릅니다. 이것은 스왑 파티션을 의미합니다.
8. 4,4,2 GB의 파티션이 생성되었습니다. Write를 선택하고 Yes를 선택합니다. 이것은 파티션 테이블을 업데이트합니다.
9. Quit를 선택하고 종료합니다.

또 다른 시나리오는 부팅 파티션을 생성해야 하는 경우입니다. 이 경우 부팅 파티션의 경우 EFI(`/dev/nvme0n1p1`)를 사용하여 수행했다면 EFI 시스템을 선택합니다. 

## Swap
Swap 이란 Linux가 컴퓨터의 임의 액세스(RAM), 메모리에서 일부 데이터를 일시적으로 이동할 수 있는 영역입니다.  
스왑 파티션은 프로세스가 할당된 메모리를 사용하는 데 필요한 메모리가 부족한 경우 사용됩니다.

예로 우리는 4GB의 RAM을 가진 컴퓨터를 가지고 있다고 가정해 봅시다.  
먼저 Video editor를 실행하고 2GB의 RAM을 사용합니다. 
동시에 Image editor를 실행하고 2GB의 RAM을 사용합니다. 남는 메모리가 없지만 우린 크롬을 열 수 있습니다. 어떻게???  
우리가 크롬을 열었을때 컴퓨터는 RAM이 더이상 없는걸 알고, Video editor 또한 1시간동안 사용하지 않은 것을 알고 있습니다.
그래서 Video editor를 inactive 상태로 변경과 함께 2GB를 스왑 파티션에 저장하고, swap 메모리로 부터 리소스를 크롬 프로세스에 할당합니다.  
이제 우리는 크롬을 사용할 수 있습니다.

### Command
이제 시스템이 어떤 종류의 스왑 영역을 사용하는지 확인하는 몇 가지 명령을 살펴보겠습니다.  
이 출력에서는 하나의 파티션이 스왑으로 사용되는 것을 볼 수 있습니다.  
```bash
$ sudo swapon --show
NAME      TYPE SIZE USED PRIO
/dev/dm-2 partition 2G 0B -2
```
현재 1개의 swap partition 있고 용량은 2GB, 사용량은 0B, 우선 순위는 -2입니다.  
이 swap area는 entirely free입니다.  
원한다면 더 많은 파티션을 추가할 수 있습니다.  
그럼 이 프로세스가 처음부터 끝까지 어떻게 보이는지 살펴보겠습니다. 먼저 `lsblk` 사용하여 어떤 파티션을 사용할 수 있는지 살펴보겠습니다.  
```bash
$ lsblk
```
스왑으로 사용할 파티션은 데이터가 없음 즉, 비어 있어야 합니다. Pat 32 또는 NTFS와 같은 파일 시스템으로 USB 스틱을 포맷한 적이 있다면 이는 비슷한 프로세스입니다.
파티션을 스왑 `mkswap` 명령을 사용합니다.  
```bash
$ sudo mkswap /dev/nvme0n1p4
```

새로 만든 1GB의 파일 swap-file을 스왑영역으로 지정한 다음 활성화시키면 현재 사용중인 스왑메모리가 1.9G에서 2.9G로 증가한 것을 확인할 수 있다.

```bash
sudo swapon --verbose /swapDisk
```

#### free = 현재 메모리상태 확인

사용중인 모든 메모리상태를 확인할 수 있으며 -m이나 -k 옵션을 통해 출력되는 단위를 바꿀 수 있다. 또한 -h 옵션은 human 의 약자로 대부분 명령에서 -h를 사용할 경우 사람이 보기 편하게 출력된다.
```bash
$ free -h
              total        used        free      shared  buff/cache   available
Mem:          1.9Gi       1.1Gi       128Mi       1.1Gi       731Mi       1.1Gi
Swap:         2.9Gi          0B       2.9Gi
```
#### 스왑 중지
```bash
$ sudo swapoff -v /swapDisk
```


파티션 대신 간단한 파일을 스왑으로 사용할 수도 있습니다.   
먼저 빈 파일을 만들고 0으로 채워야 합니다. 이진수에서는 0이나 1을 가질 수 있기 때문입니다.    

```bash
$ sudo dd if=/dev/zero of=/swapFile bs=1M count=128 status=progress
```
Unix 계열 운영 체제에서 /dev/zero는 널 문자(ASCII NUL, 0x00)의 끝없는 스트림을 제공하는 특수 파일입니다. 널 문자는 0과 동일한 8비트로 구성된 바이트입니다.  
dd 명령은 파일을 복사하거나 변환하는 데 사용되는 유닉스 명령입니다.  

* if = input file
  *  /dev/zero 에게 입력 파일을 사용하도록 지시합니다. 그리고 이는 응용 프로그램이 읽을 때 무한한 수의 0을 생성하는 특수 장치 파일입니다.
* of = output file
* bs = block size
* count = block count
이후  루트 사용자만 이 파일을 읽고 쓸 수 있도록 권한을 설정하겠습니다. 다음 명령을 사용하면 됩니다.
```bash
$ sudo chmod 600 /swapFile
```

128MB의 빈 파일을 만들었습니다. 이제 이 파일을 스왑으로 사용할 수 있습니다.  
```bash
$ sudo mkswap /swapFile
$ sudo swapon /swapFile
```

다시 스왑 목록을 확인해 보겠습니다. 이제 2개의 스왑 영역이 있습니다.  
```bash
$ sudo swapon --show
NAME      TYPE SIZE USED PRIO
/dev/dm-2 partition 2G 0B  -2
/swapFile file 128M   0B   -3
```



#### 부팅시 생성한 swap 영역을 자동으로 설정
mkswap , swapon 명령을 통해 스왑영역을 활성화 시킨 뒤 재부팅하면 비활성화상태가 되어있다.  
이를 해결하기 위해선 /etc/fstab 파일을 수정해야한다.  
```bash
# 부팅시 읽어오는 파티션 정보를 수정하자.
$ sudo vim /etc/fstab
```

 

 ## Refer
 * https://wiseworld.tistory.com/entry/%EB%A6%AC%EB%88%85%EC%8A%A4-swap-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EA%B4%80%EB%A6%AC-mkswap-dd
 * [디스크 쿼터 사용법 (quotacheck, repquota)](https://wiseworld.tistory.com/entry/%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%94%94%EC%8A%A4%ED%81%AC-%EC%BF%BC%ED%84%B0-%EC%82%AC%EC%9A%A9%EB%B2%95-quotacheck-repquota?category=852155)